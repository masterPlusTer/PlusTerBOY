#include <Adafruit_NeoPixel.h>

// Definir los pines
const int BUTTON_B = 4; // Botón B
const int BUTTON_A = 5; // Botón A
uint8_t buttons[] = {6, 7, 8, 9}; // Botones: arriba, abajo, izquierda, derecha
const int NEOPIXEL_PIN = 2;
const int BUZZER_PIN = 3; // Pin del buzzer

// Definir el número de LEDs en la matriz
const int NUM_LEDS_X = 22; // Tamaño ajustado
const int NUM_LEDS_Y = 22;
const int NUM_LEDS = NUM_LEDS_X * NUM_LEDS_Y;

// Crear una instancia de la matriz de NeoPixels
Adafruit_NeoPixel pixels(NUM_LEDS, NEOPIXEL_PIN, NEO_GRB + NEO_KHZ800);

// Estado previo de los botones
bool previousButtonB = true;
bool previousButtonA = true;
bool previousButtonState[4] = {true, true, true, true};

void setup() {
  // Configurar los pines de los pulsadores como entrada con resistencia de pull-up
  pinMode(BUTTON_B, INPUT_PULLUP);
  pinMode(BUTTON_A, INPUT_PULLUP);
  for (uint8_t i = 0; i < 4; i++) {
    pinMode(buttons[i], INPUT_PULLUP);
  }

  // Configurar el pin del buzzer como salida
  pinMode(BUZZER_PIN, OUTPUT);

  // Inicializar la matriz de NeoPixels
  pixels.begin();
  pixels.setBrightness(1); // Reducir el brillo al mínimo
  pixels.clear();
  pixels.show();
}

void loop() {
  unsigned long currentTime = millis();

  // Leer el estado del botón B
  bool currentButtonB = digitalRead(BUTTON_B);
  if (!currentButtonB && previousButtonB) {
    buzzClick(1000, 100); // Emitir clic solo al presionar el botón
    executePattern(0); // Por ejemplo, patrón 1
  }
  previousButtonB = currentButtonB;

  // Leer el estado del botón A
  bool currentButtonA = digitalRead(BUTTON_A);
  if (!currentButtonA && previousButtonA) {
    buzzClick(1200, 100); // Emitir clic solo al presionar el botón
    executePattern(1); // Por ejemplo, patrón 2
  }
  previousButtonA = currentButtonA;

  // Leer el estado de los botones direccionales
  for (uint8_t i = 0; i < 4; i++) {
    bool currentState = digitalRead(buttons[i]);
    if (!currentState && previousButtonState[i]) {
      buzzClick(800 + i * 100, 100); // Emitir clic solo al presionar el botón
      executePattern(i + 2);         // Los patrones 3 a 6
    }
    previousButtonState[i] = currentState;
  }
}

void executePattern(uint8_t pattern) {
  pixels.clear();

  switch (pattern) {
    case 0: // Patrón 1: Barrido horizontal
      for (int y = 0; y < NUM_LEDS_Y; y++) {
        for (int x = 0; x < NUM_LEDS_X; x++) {
          int ledIndex = (y % 2 == 0) ? x + y * NUM_LEDS_X : (NUM_LEDS_X - 1 - x) + y * NUM_LEDS_X;
          pixels.setPixelColor(ledIndex, pixels.Color(0, 0, 255)); // Azul
          pixels.show();
          delay(50);
          pixels.setPixelColor(ledIndex, pixels.Color(0, 0, 0)); // Apagar
        }
      }
      break;

    case 1: // Patrón 2: Barrido vertical
      for (int x = 0; x < NUM_LEDS_X; x++) {
        for (int y = 0; y < NUM_LEDS_Y; y++) {
          int ledIndex = (y % 2 == 0) ? x + y * NUM_LEDS_X : (NUM_LEDS_X - 1 - x) + y * NUM_LEDS_X;
          pixels.setPixelColor(ledIndex, pixels.Color(0, 255, 0)); // Verde
          pixels.show();
          delay(50);
          pixels.setPixelColor(ledIndex, pixels.Color(0, 0, 0)); // Apagar
        }
      }
      break;

    case 2: // Patrón 3: Encender todos los LEDs en rojo
      for (int i = 0; i < NUM_LEDS; i++) {
        pixels.setPixelColor(i, pixels.Color(255, 0, 0)); // Rojo
      }
      pixels.show();
      delay(500);
      break;

    case 3: // Patrón 4: Parpadeo aleatorio
      for (int i = 0; i < 50; i++) {
        int ledIndex = random(NUM_LEDS);
        pixels.setPixelColor(ledIndex, pixels.Color(random(255), random(255), random(255)));
        pixels.show();
        delay(50);
        pixels.setPixelColor(ledIndex, 0); // Apagar
      }
      break;

    default:
      break;
  }
}

void buzzClick(uint16_t frequency, uint16_t duration) {
  tone(BUZZER_PIN, frequency, duration); // Emitir tono
}
